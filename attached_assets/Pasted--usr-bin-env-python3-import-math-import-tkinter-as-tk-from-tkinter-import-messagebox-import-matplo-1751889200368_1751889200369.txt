#!/usr/bin/env python3
import math
import tkinter as tk
from tkinter import messagebox
import matplotlib.pyplot as plt
import numpy as np

def calc_shadow_spacing(lat, tilt, length):
    """
    Calcula la declinación solar, la altura solar a mediodía y la distancia mínima entre filas de módulos para el 21 de diciembre.
    :param lat: Latitud en grados
    :param tilt: Inclinación de los paneles en grados
    :param length: Longitud del panel en metros
    :return: (delta, ho, dmin)
    """
    day_julian = 355  # 21 de diciembre
    delta = 23.45 * math.sin(math.radians(360 * (284 + day_julian) / 365))
    ho = 90 - lat + delta
    dmin = length * math.sin(math.radians(ho + tilt)) / math.sin(math.radians(ho))
    return delta, ho, dmin


def plot_panel_rows(tilt, length, dmin, drec, lat):
    """
    Dibuja dos filas de paneles separadas por dmin y drec sin mostrar el rayo solar.
    Agrega 2 m de altura extra.
    """
    beta = math.radians(tilt)
    x1 = np.array([0, length * math.cos(beta)])
    y1 = np.array([0, length * math.sin(beta)])
    x2 = x1 + dmin
    y2 = y1
    max_h = y1[1]

    fig, ax = plt.subplots()
    # Suelo
    ax.plot([-0.1*dmin, x2[1] + length*0.2], [0, 0], 'k')
    # Filas de paneles
    ax.plot(x1, y1, 'b', linewidth=3, label='Fila 1')
    ax.plot(x2, y2, 'b', linewidth=3, label='Fila 2')

    # Anotación de dmin en la base de las filas
    y_base = 0.1
    ax.annotate('', xy=(0, y_base), xytext=(dmin, y_base), arrowprops=dict(arrowstyle='<->'))
    ax.text(dmin/2, y_base + 0.05, f'dmin = {dmin:.3f} m', ha='center', va='bottom')

    # Anotación de distancia recomendada (25% más)
    y_rec = y_base + 0.25
    ax.annotate('', xy=(0, y_rec), xytext=(drec, y_rec), arrowprops=dict(arrowstyle='<->'))
    ax.text(drec/2, y_rec + 0.05, f'drec = {drec:.3f} m', ha='center', va='bottom')

    # Texto de entrada
    textstr = f"Latitud: {lat:.3f}°\nInclinación: {tilt:.3f}°\nLongitud: {length:.3f} m"
    ax.text(0.02, 0.95, textstr, transform=ax.transAxes, fontsize=10,
            verticalalignment='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

    # Límites y aspecto: añadir espacio para la flecha de drec
    max_x = max(drec, x2[1] + length*0.2)
    ax.set_xlim(-0.1*dmin, max_x)
    ax.set_ylim(-0.1*length, max_h + 2)
    ax.set_aspect('equal', 'box')
    ax.set_xlabel('Distancia horizontal (m)')
    ax.set_ylabel('Altura (m)')
    ax.legend()
    ax.set_title('Distancia mínima entre paneles')
    plt.tight_layout()
    plt.show()


def on_calculate():
    try:
        lat = float(entry_lat.get())
        tilt = float(entry_tilt.get())
        length = float(entry_length.get())
    except ValueError:
        messagebox.showerror("Error", "Introduce valores numéricos válidos.")
        return
    # Cálculo de distancias
    delta, ho, dmin = calc_shadow_spacing(lat, tilt, length)
    # Round results to 3 decimals
    dmin_rounded = round(dmin, 3)
    drec = round(dmin * 1.25, 3)
    # Mostrar resultados
    result_text = (
        f"Declinación δ: {round(delta,3):.3f}°\n"
        f"Altura solar ho: {round(ho,3):.3f}°\n"
        f"dmin (mín): {dmin_rounded:.3f} m\n"
        f"Distancia recomendada: {drec:.3f} m"
    )
    messagebox.showinfo("Resultados", result_text)
    # Dibujo de la gráfica con drec
    plot_panel_rows(tilt, length, dmin, drec, lat)

# GUI
root = tk.Tk()
root.title("Calculadora de sombreado PV")
root.geometry("350x200")  # Ventana de datos
root.resizable(False, False)

frame = tk.Frame(root, padx=15, pady=15)
frame.pack()

# Latitud
tk.Label(frame, text="Latitud (°):").grid(row=0, column=0, sticky='e', pady=5)
entry_lat = tk.Entry(frame, width=12)
entry_lat.grid(row=0, column=1, pady=5)

# Inclinación
tk.Label(frame, text="Inclinación (°):").grid(row=1, column=0, sticky='e', pady=5)
entry_tilt = tk.Entry(frame, width=12)
entry_tilt.grid(row=1, column=1, pady=5)

# Longitud
tk.Label(frame, text="Longitud (m):").grid(row=2, column=0, sticky='e', pady=5)
entry_length = tk.Entry(frame, width=12)
entry_length.grid(row=2, column=1, pady=5)

# Botón de cálculo
tk.Button(frame, text="Calcular y mostrar gráfica", command=on_calculate).grid(row=3, column=0, columnspan=2, pady=10)

root.mainloop()

